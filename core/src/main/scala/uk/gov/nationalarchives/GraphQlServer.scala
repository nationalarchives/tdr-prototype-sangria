package uk.gov.nationalarchives

import io.circe.Json
import sangria.ast.Document
import sangria.execution.Executor
import sangria.macros.derive._
import sangria.marshalling.circe._
import sangria.parser.QueryParser
import sangria.schema.{Argument, Field, IntType, ListType, ObjectType, OptionType, Schema, StringType, fields}
import slick.jdbc.PostgresProfile.api._

import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.Future
import scala.util.{Failure, Success, Try}

object GraphQlServer {

  private val ConsignmentType = deriveObjectType[ConsignmentDao, Consignment]()
  private val ConsignmentNameArg = Argument("name", StringType)
  private val ConsignmentIdArg = Argument("id", IntType)

  private val QueryType = ObjectType("Query", fields[ConsignmentDao, Unit](
    Field("getConsignments", ListType(ConsignmentType), resolve = ctx => ctx.ctx.all),
    Field(
      "getConsignment",
      OptionType(ConsignmentType),
      arguments = List(ConsignmentIdArg),
      resolve = ctx => ctx.ctx.get(ctx.arg(ConsignmentIdArg))
    )
  ))

  private val MutationType = ObjectType("Mutation", fields[ConsignmentDao, Unit](
    Field(
      "createConsignment",
      ConsignmentType,
      arguments = List(ConsignmentNameArg),
      resolve = ctx => ctx.ctx.create(Consignment(name = ctx.arg(ConsignmentNameArg))))
  ))

  private val schema = Schema(QueryType, Some(MutationType))

  def send(request: GraphQlRequest): Future[Json] = {
    println(s"Got GraphQL request '$request'")

    val query: Try[Document] = QueryParser.parse(request.query)

    query match {
      case Success(doc) =>
        Executor.execute(schema, doc, ConsignmentDao)
      case Failure(e) =>
        Future.failed(e)
    }
  }
}

case class GraphQlRequest(query: String)

trait ConsignmentDao {
  def all: Future[Seq[Consignment]]
  def get(id: Int): Future[Option[Consignment]]
  def create(consignment: Consignment): Future[Consignment]
}

object ConsignmentDao extends ConsignmentDao {

  // Slick requires every non-nullable column to have a value on insert, even the ID column, so provide an arbitrary
  // ID which will be overwritten by the auto-incrementing value generated by PostgreSQL
  private val dummyId = 0

  // Load PostgreSQL driver into classpath
  Class.forName("org.postgresql.Driver")

  val db = Database.forURL(
    url = "jdbc:postgresql://localhost/tdrapi",
    user = "postgres",
    password = "devdbpassword",
    driver = "org.postgresql.Driver"
  )

  val consignments = TableQuery[Consignments]

  override def all: Future[Seq[Consignment]] = {
    db.run(consignments.result).map(results => {
      results.map(result => Consignment(Some(result._1), result._2))
    })
  }

  override def get(id: Int): Future[Option[Consignment]] = {
    db.run(consignments.filter(_.id === id).result).map(results => {
      results.headOption.map(result => Consignment(Some(result._1), result._2))
    })
  }

  override def create(consignment: Consignment): Future[Consignment] = {
    // TODO: Examples use case class rather than tuple. How?
    val insertQuery = consignments returning consignments.map(_.id) into ((consignment, id) => (id, consignment._2))

    val insertAction = insertQuery += (dummyId, consignment.name)
    db.run(insertAction).map(result => {
      Consignment(Some(result._1), result._2)
    })
  }
}

case class Consignment(id: Option[Int] = None, name: String)

class Consignments(tag: Tag) extends Table[(Int, String)](tag, "consignments") {
  def id = column[Int]("id", O.PrimaryKey, O.AutoInc)
  def name = column[String]("name")

  override def * = (id, name)
}