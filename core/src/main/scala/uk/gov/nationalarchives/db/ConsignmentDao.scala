package uk.gov.nationalarchives.db

import slick.jdbc.PostgresProfile.api._
import slick.lifted.{ProvenShape, TableQuery}
import uk.gov.nationalarchives.model.ConsignmentDbData

import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.Future

class ConsignmentDao {
  // Slick requires every non-nullable column to have a value on insert, even the ID column, so provide an arbitrary
  // ID which will be overwritten by the auto-incrementing value generated by PostgreSQL
  private val dummyId = 0

  // Load PostgreSQL driver into classpath
  Class.forName("org.postgresql.Driver")

  private val dbConfig = sys.env.get("TDR_API_ENVIRONMENT") match {
    case Some("TEST") => PrototypeDbConfig
    case _ => DevDbConfig
  }

  private val db = Database.forURL(
    url = dbConfig.url,
    user = dbConfig.username,
    password = dbConfig.password,
    driver = "org.postgresql.Driver"
  )

  private val consignments = TableQuery[Consignments]

  private val insertQuery = consignments returning consignments.map(_.id) into ((consignment, id) => consignment.copy(id = Some(id)))

  def all: Future[Seq[ConsignmentDbData]] = {
    db.run(consignments.result)
  }

  def get(id: Int): Future[Option[ConsignmentDbData]] = {
    db.run(consignments.filter(_.id === id).result).map(_.headOption)
  }

  def create(consignment: ConsignmentDbData): Future[ConsignmentDbData] = {
    db.run(insertQuery += consignment)
  }
}

class Consignments(tag: Tag) extends Table[ConsignmentDbData](tag, "consignments") {

  // TODO: Where should this be defined? Dedup with SeriesDao
  private val seriesQueries = TableQuery[SeriesTable]

  def id = column[Int]("id", O.PrimaryKey, O.AutoInc)
  def name = column[String]("name")
  def seriesId = column[Int]("series_id")
  def series = foreignKey("consignment_series_fk", seriesId, seriesQueries)(_.id)

  override def * : ProvenShape[ConsignmentDbData] = (id.?, name, seriesId).mapTo[ConsignmentDbData]
}